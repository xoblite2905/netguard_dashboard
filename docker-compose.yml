version: '3.8'

services:
  # === Elastic Stack (Unchanged) ===
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.17.20
    container_name: elasticsearch
    environment:
      - cluster.name=netguard-cluster # Added this for clarity
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms2g -Xmx2g
    ports: ["9200:9200"]
    volumes: ["es_data:/usr/share/elasticsearch/data"]
    networks: ["netguard-net"]
    deploy:
      resources:
        limits:
          memory: 4g   # Allocate 4GB total RAM to the Elasticsearch container
          cpus: '2'    # Allocate 2 CPU cores
        reservations: # Optional: Reserve a minimum amount of resources
          memory: 2g
          cpus: '1'
    healthcheck:
      test: ["CMD-SHELL", "curl -fs http://localhost:9200/_cluster/health || exit 1"]
      interval: 10s
      timeout: 10s
      retries: 10

  kibana:
    image: docker.elastic.co/kibana/kibana:7.17.20
    container_name: kibana
    ports: ["5601:5601"]
    environment: ["ELASTICSEARCH_HOSTS=http://elasticsearch:9200"]
    depends_on: { elasticsearch: { condition: service_healthy } }
    restart: on-failure
    networks: ["netguard-net"]

  # === YOUR Application's PostgreSQL Database (Unchanged) ===
  db:
    image: postgres:15-alpine
    container_name: postgres_db
    restart: unless-stopped
    ports: ["127.0.0.1:5432:5432"]
    environment: ["POSTGRES_USER=${POSTGRES_USER}", "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}", "POSTGRES_DB=${POSTGRES_DB}"]
    volumes: ["postgres_data:/var/lib/postgresql/data"]
    networks: ["netguard-net"]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10

  netguard_app:
    build:
      context: .
      dockerfile: Dockerfile.netguard
    container_name: netguard_app
    network_mode: "host"
    cap_add: [ "NET_ADMIN", "NET_RAW" ]
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      #- ./backend/app:/app/app
      - suricata_logs:/var/log/suricata:ro
      - packet_stream:/stream
    depends_on:
      elasticsearch:
        condition: service_healthy
      db:
        condition: service_healthy
    environment:
      - IFACE=${IFACE}
      - SCAN_TARGET_CIDR=${SCAN_TARGET_CIDR}
      # Correctly point to localhost for all services
      - ELASTICSEARCH_URI=http://127.0.0.1:9200
      - DATABASE_URL=postgresql+pg8000://${POSTGRES_USER}:${POSTGRES_PASSWORD}@127.0.0.1:5432/${POSTGRES_DB}
      - PYTHONUNBUFFERED=1
      # The variables below are likely not used by your final code, but keeping them consistent is good practice.
      - DB_HOST=127.0.0.1
      - DB_PORT=5432
      - DB_USER=${POSTGRES_USER}
      - DB_PASSWORD=${POSTGRES_PASSWORD}
      - DB_NAME=${POSTGRES_DB}
    command: >
      sh -c "
        echo 'Dependencies are healthy, preparing environment...' &&
        mkdir -p /stream &&
        ([ -p /stream/scapy.pcap ] || mkfifo /stream/scapy.pcap) &&
        echo 'Packet stream pipe created.' &&
        python -m app.create_db &&
        echo 'Database tables ready. Starting Uvicorn server.' &&
        uvicorn app.main:app --host 0.0.0.0 --port 8080 --log-level info
      "

  packet-streamer:
    build:
      context: .
      dockerfile: Dockerfile.tshark
    container_name: packet-streamer
    restart: unless-stopped
    network_mode: "host"
    cap_add: [ "NET_RAW", "NET_ADMIN" ]
    volumes:
      - packet_stream:/stream
    command: >
      sh -c "
        echo 'Waiting for pipe to be created...' &&
        while [ ! -p /stream/scapy.pcap ]; do sleep 1; done &&
        echo 'Pipe found. Starting tshark stream...' &&
        tshark -i ${IFACE} -l -T ek > /stream/scapy.pcap
      "



  # === Network Monitoring Tools (NOW IN LIVE MODE) ===
  zeek:
    build:
      context: .
      dockerfile: Dockerfile.zeek
    container_name: zeek
    restart: on-failure
    volumes:
      - zeek_logs:/opt/zeek/logs
      - pcap_spool:/pcaps # CORRECTED: Removed ":ro" to allow file deletion
      - ./local.zeek:/opt/zeek/share/zeek/site/local.zeek
    command: /usr/local/bin/process_pcaps.sh

  suricata:
    image: jasonish/suricata:latest
    container_name: suricata
    restart: unless-stopped
    user: root
    network_mode: "host"
    cap_add: [ "NET_ADMIN", "NET_RAW", "SYS_NICE" ]
    volumes:
      - ./suricata.yaml:/etc/suricata/suricata.yaml
      - suricata_logs:/var/log/suricata
      - pcap_spool:/var/log/suricata/pcaps
    command:
      - -c
      - /etc/suricata/suricata.yaml
      - -i
      - ${IFACE}
  filebeat:
    image: docker.elastic.co/beats/filebeat:7.17.20
    container_name: filebeat
    depends_on: {elasticsearch: {condition: service_healthy}, zeek: {condition: service_started}, suricata: {condition: service_started}}
    user: root
    restart: on-failure
    volumes:
      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - zeek_logs:/var/log/zeek:ro
      - suricata_logs:/var/log/suricata:ro
    networks: ["netguard-net"]
    command: filebeat -e -d "*" -strict.perms=false

# === Volumes Definitions ===
volumes:
  es_data: {}
  postgres_data: {}
  zeek_logs: {}
  suricata_logs: {}
  pcap_spool: {}
  packet_stream: {}

# === Network Definitions ===
networks:
  netguard-net: {}
