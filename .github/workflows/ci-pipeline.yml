# Name for your CI workflow, will be displayed on the "Actions" tab in GitHub
name: Netguard CI - Build and Integration Test

# -----------------
# --- Triggers ----
# -----------------
# This workflow will run on every push to the 'main' branch
# and on any pull request that targets the 'main' branch.
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# -----------------
# ------ Jobs -----
# -----------------
jobs:
  # A single job in this pipeline named "build-and-test"
  build-and-test:
    # Use the latest version of Ubuntu for our virtual machine
    runs-on: ubuntu-latest

    # These are the sequential steps the job will run
    steps:
      # ------------------
      # --- 1. Setup -----
      # ------------------

      # Step 1.1: Check out your repository's code so the runner can access it
      - name: Check out code
        uses: actions/checkout@v3

      # Step 1.2: Set up QEMU for multi-platform Docker builds (good practice)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      # Step 1.3: Set up Docker Buildx for faster, better builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # -----------------------------------
      # --- 2. Create .env from Secrets ---
      # -----------------------------------
      # This is the most CRITICAL step for security.
      # It takes the secrets you will configure in GitHub and writes them
      # to a temporary .env file for your script to use.
      - name: Create .env file
        run: |
          echo "IFACE=eth0" >> .env
          echo "SCAN_TARGET_CIDR=192.168.76.140/24" >> .env
          echo "POSTGRES_USER=${{ secrets.POSTGRES_USER }}" >> .env
          echo "POSTGRES_DB=${{ secrets.POSTGRES_DB }}" >> .env
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env
          echo "DB_HOST=postgres_db" >> .env # Use localhost since everything runs on the runner
          echo "DB_PORT=5432" >> .env
          echo "DB_DRIVER=pg8000" >> .env
          echo "ELASTICSEARCH_URI=http://elasticsearch:9200" >> .env
          echo "DATABASE_URL=postgresql+pg8000://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres_db:5432/${{ secrets.POSTGRES_DB }}" >> .env
      
      # ------------------------------------
      # --- 3. Run The Integration Test ----
      # ------------------------------------
      # The core of your CI test.
      - name: Run the full application stack
        run: |
          # Make your main execution script runnable
          # Based on your file list, run_system.sh looks like the main one. 
          # If it's exucute.sh, change the name here.
          chmod +x run_system.sh

          # Run the script in the background using '&'.
          # If we don't, it will run forever and the CI job will never finish.
          ./run_system.sh &

      # ---------------------------
      # --- 4. Health Checks ------
      # ---------------------------
      # This is how we know if the test "passed".
      # We wait for a bit and then check if the services are actually responding.
      - name: Wait for services to start
        run: |
          echo "Waiting for 60 seconds for all services to initialize..."
          sleep 60

      - name: Check if backend API is responsive
        # The FastAPI backend likely runs on port 8000. We'll use curl to check if it's up.
        # If the curl command fails, the entire workflow will fail.
        run: curl --fail http://localhost:8000/docs || exit 1

      - name: Check frontend or other service (optional)
        # You could add more checks here, for example, checking Elasticsearch.
        run: curl --fail http://localhost:9200 || exit 1
